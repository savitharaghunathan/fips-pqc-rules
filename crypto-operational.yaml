- ruleID: fips-go-ops-00100
  labels:
    - "konveyor.io/target=go"
  effort: 4
  category: mandatory
  description: "Unacceptable: Hardcoded cryptographic key detected"
  when:
    or:
      - builtin.filecontent:
          pattern: 'aes\.NewCipher\s*\(\s*\[\]byte\s*\(\s*"[^"]+"\s*\)\s*\)'
          filePattern: "*.go"
      - builtin.filecontent:
          pattern: 'des\.NewCipher\s*\(\s*\[\]byte\s*\(\s*"[^"]+"\s*\)\s*\)'
          filePattern: "*.go"
      - builtin.filecontent:
          pattern: 'rc4\.NewCipher\s*\(\s*\[\]byte\s*\(\s*"[^"]+"\s*\)\s*\)'
          filePattern: "*.go"
      - builtin.filecontent:
          pattern: 'hmac\.New\s*\([^,]+,\s*\[\]byte\s*\(\s*"[^"]+"\s*\)\s*\)'
          filePattern: "*.go"
  message: |
    Critical Security Vulnerability. Hardcoded cryptographic key detected in source code.

    Hardcoded keys are:
    - Exposed in version control history
    - Visible to anyone with code access
    - Impossible to rotate without code changes
    - Violate key management best practices

    Action: Load keys from secure sources:
    - Environment variables (for development)
    - Kubernetes Secrets
    - HashiCorp Vault
    - AWS KMS / Azure Key Vault / GCP KMS
    - Hardware Security Modules (HSM)

    Never commit cryptographic keys to source code.
  tag:
    - "FIPS-140=Unacceptable"
    - "Crypto=Hardcoded-Key"
    - "CWE=CWE-798"

- ruleID: fips-go-ops-00101
  labels:
    - "konveyor.io/target=go"
  effort: 3
  category: mandatory
  description: "Unacceptable: Hardcoded IV/Nonce detected"
  when:
    or:
      - builtin.filecontent:
          pattern: 'cipher\.NewCBCEncrypter\s*\([^,]+,\s*\[\]byte\s*\(\s*"[^"]+"\s*\)\s*\)'
          filePattern: "*.go"
      - builtin.filecontent:
          pattern: 'cipher\.NewCBCDecrypter\s*\([^,]+,\s*\[\]byte\s*\(\s*"[^"]+"\s*\)\s*\)'
          filePattern: "*.go"
      - builtin.filecontent:
          pattern: 'cipher\.NewCFBEncrypter\s*\([^,]+,\s*\[\]byte\s*\(\s*"[^"]+"\s*\)\s*\)'
          filePattern: "*.go"
      - builtin.filecontent:
          pattern: 'cipher\.NewOFB\s*\([^,]+,\s*\[\]byte\s*\(\s*"[^"]+"\s*\)\s*\)'
          filePattern: "*.go"
      - builtin.filecontent:
          pattern: 'cipher\.NewCTR\s*\([^,]+,\s*\[\]byte\s*\(\s*"[^"]+"\s*\)\s*\)'
          filePattern: "*.go"
  message: |
    Critical Security Vulnerability. Hardcoded initialization vector (IV) or nonce detected.

    Static IVs break the security of encryption:
    - Same plaintext produces same ciphertext (CBC)
    - Enables plaintext recovery attacks
    - GCM nonce reuse is catastrophic (key recovery possible)

    Action: Generate IVs/nonces using crypto/rand:
      iv := make([]byte, aes.BlockSize)
      if _, err := io.ReadFull(rand.Reader, iv); err != nil {
          panic(err)
      }

    For GCM, never reuse a nonce with the same key.
  tag:
    - "FIPS-140=Unacceptable"
    - "Crypto=Static-IV"
    - "CWE=CWE-330"

- ruleID: fips-go-ops-00200
  labels:
    - "konveyor.io/target=go"
  effort: 3
  category: potential
  description: "Requires Analysis: math/rand detected - review for cryptographic misuse"
  when:
    or:
      - go.referenced:
          pattern: "math/rand"
      - go.referenced:
          pattern: "math/rand/v2"
  message: |
    math/rand Package Detected. Review usage context for security implications.

    math/rand (and math/rand/v2) are NOT cryptographically secure:
    - Output can be predicted if seed is known
    - Default seed is deterministic (time-based before Go 1.20)
    - math/rand/v2 (Go 1.22+) has improved seeding but is still not crypto-safe
    - MUST NOT be used for security-sensitive purposes

    math/rand is UNACCEPTABLE for:
    - Key generation
    - IV/Nonce generation
    - Token/Session ID generation
    - Salt generation
    - Any security-sensitive randomness

    math/rand is ACCEPTABLE for:
    - Shuffling (non-security)
    - Simulations and games
    - Random delays/jitter
    - Test data generation

    Action: Review usage. If used for any security purpose, replace with crypto/rand:
      import "crypto/rand"

      key := make([]byte, 32)
      if _, err := rand.Read(key); err != nil {
          panic(err)
      }
  tag:
    - "FIPS-140=Requires-Analysis"
    - "Crypto=Weak-Random"
    - "CWE=CWE-338"

- ruleID: fips-go-ops-00300
  labels:
    - "konveyor.io/target=go"
  effort: 2
  category: potential
  description: "Requires Analysis: Static salt detected in password hashing"
  when:
    or:
      - builtin.filecontent:
          pattern: 'pbkdf2\.Key\s*\([^,]+,\s*\[\]byte\s*\(\s*"[^"]+"\s*\)'
          filePattern: "*.go"
      - builtin.filecontent:
          pattern: 'scrypt\.Key\s*\([^,]+,\s*\[\]byte\s*\(\s*"[^"]+"\s*\)'
          filePattern: "*.go"
      - builtin.filecontent:
          pattern: 'argon2\.\w+\s*\([^,]+,\s*\[\]byte\s*\(\s*"[^"]+"\s*\)'
          filePattern: "*.go"
  message: |
    Potential Issue. Static salt detected in password hashing.

    Salts should be:
    - Unique per password
    - Randomly generated (16+ bytes)
    - Stored alongside the hash

    Static salts enable:
    - Rainbow table attacks
    - Parallel cracking of multiple passwords

    Action: Generate unique salts for each password:
      salt := make([]byte, 16)
      if _, err := rand.Read(salt); err != nil {
          return err
      }
      hash := pbkdf2.Key(password, salt, iterations, keyLen, sha256.New)
  tag:
    - "FIPS-140=Requires-Analysis"
    - "Crypto=Static-Salt"
    - "CWE=CWE-760"

- ruleID: fips-go-ops-00400
  labels:
    - "konveyor.io/target=go"
  effort: 2
  category: potential
  description: "Requires Analysis: GCM/AEAD usage - verify nonce uniqueness"
  when:
    or:
      - builtin.filecontent:
          pattern: 'cipher\.NewGCM\s*\('
          filePattern: "*.go"
      - builtin.filecontent:
          pattern: 'cipher\.NewGCMWithNonceSize\s*\('
          filePattern: "*.go"
      - builtin.filecontent:
          pattern: 'chacha20poly1305\.New\s*\('
          filePattern: "*.go"
      - builtin.filecontent:
          pattern: 'chacha20poly1305\.NewX\s*\('
          filePattern: "*.go"
  message: |
    AEAD Usage Detected. GCM and ChaCha20-Poly1305 require unique nonces for security.

    Critical Requirements:
    - Nonce MUST be unique for each encryption with same key
    - Nonce reuse with same key = catastrophic key recovery
    - GCM: 12-byte nonces are standard
    - XChaCha20-Poly1305: 24-byte nonces (safer for random generation)

    Safe patterns:
    1. Random nonces (for limited messages per key):
       nonce := make([]byte, gcm.NonceSize())
       if _, err := rand.Read(nonce); err != nil { ... }

    2. Counter-based nonces (for high-volume):
       nonce := make([]byte, 12)
       binary.BigEndian.PutUint64(nonce[4:], atomic.AddUint64(&counter, 1))

    3. XChaCha20-Poly1305 (safer random nonces):
       aead, _ := chacha20poly1305.NewX(key)
       nonce := make([]byte, 24)
       rand.Read(nonce)

    Action: Review nonce generation to ensure uniqueness across all encryptions.
  tag:
    - "FIPS-140=Requires-Analysis"
    - "Crypto=AEAD-Nonce"
    - "CWE=CWE-323"

